---

- name: Check configuration
  assert:
    that:
    - graph_core_request|int > 0
    - graph_core_limit|int >= graph_core_request|int
    - graph_password|string|length > 0
    - graph_password|string != 'neo4j'

# Check or create the namespace...

- name: Get expected namespace
  k8s_info:
    kind: Namespace
    name: "{{ graph_namespace }}"
  register: namespace_info

- name: Assert namespace exists
  assert:
    that: namespace_info.resources|length > 0
    fail_msg: Namespace '{{ graph_namespace }}' does not exist
  when: graph_volume_size_g|int == 0

- name: Create namespace
  k8s:
    definition: "{{ lookup('template', 'namespace.yaml.j2') }}"
  when: graph_volume_size_g|int > 0

- name: Create Service Account
  k8s:
    definition: "{{ lookup('template', 'serviceaccount.yaml.j2') }}"

- name: Bind Role to Service Account
  k8s:
    definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
  loop:
  - role
  - rolebinding
  when: graph_sa_psp|string|length > 0

# Deploy the graph secrets...

- name: Check secrets
  k8s_info:
    kind: Secret
    api_version: v1
    namespace: "{{ graph_namespace }}"
    name: graph-secrets
  register: graph_s_result

- name: Set secret facts
  set_fact:
    aws_access_key_id_fact: "{{ aws_access_key_id }}"
    aws_secret_access_key_fact: "{{ aws_secret_access_key }}"
    neo4j_auth_fact: "neo4j/{{ graph_password }}"
  when: graph_s_result.resources|length == 0

- name: Set secret facts (pre-deployed secrets)
  set_fact:
    aws_access_key_id_fact: "{{ graph_s_result.resources[0].data.aws_access_key_id|b64decode }}"
    aws_secret_access_key_fact: "{{ graph_s_result.resources[0].data.aws_secret_access_key|b64decode }}"
    neo4j_auth_fact: "{{ graph_s_result.resources[0].data.neo4j_auth|b64decode }}"
  when: graph_s_result.resources|length == 1

- name: Deploy secrets
  k8s:
    definition: "{{ lookup('template', 'secrets.yaml.j2') }}"
  when: graph_s_result.resources|length == 0

# Set cypher script variables...

- name: Set 'once' cypher script content
  set_fact:
    cypher_script_once_content: "{{ lookup('file',  graph_cypher_once_script) }}"
  when: graph_cypher_once_script|string|length > 0

- name: Set 'always' cypher script content
  set_fact:
    cypher_script_always_content: "{{ lookup('file',  graph_cypher_always_script) }}"
  when: graph_cypher_always_script|string|length > 0

# Deploy volume claims

- name: Assert volume variables
  assert:
    that: graph_pvc_storage_class|length > 0
  when: graph_volume_size_g|int > 0

- name: Deploy volume claim
  k8s:
    definition: "{{ lookup('template', 'pvc-graph.yaml.j2') }}"
    wait: yes
  when: graph_volume_size_g|int > 0

# Best practice ... wait for the PVC to bind.
# e.g. wait until resources[0].status.phase == Bound (initially Pending)

- name: Wait for volume claim to bind
  k8s_info:
    kind: PersistentVolumeClaim
    name: "{{ graph_pvc }}"
    namespace: "{{ graph_namespace }}"
  register: pvc_result
  until: >-
    pvc_result.resources|length > 0
    and pvc_result.resources[0].status is defined
    and pvc_result.resources[0].status.phase is defined
    and pvc_result.resources[0].status.phase == 'Bound'
  delay: 5
  retries: "{{ (bind_timeout|int / 5)|int }}"
  when:
  - graph_volume_size_g|int > 0
  - wait_for_bind|bool

# Deploy the graph...
#
# Which consists of checking for cypher script content in our 'files' directory
# and setting corresponding variables. The Graph is deployed with an
# initContainer that populates the graph loader directory before the Graph
# (neo4j) container starts.

- name: Deploy Graph
  k8s:
    definition: "{{ lookup('template', 'statefulset.yaml.j2') }}"
    wait: yes
    wait_timeout: "{{ graph_pod_ready_timeout }}"

- name: Deploy Graph Services
  k8s:
    definition: "{{ lookup('template', item) }}"
  loop:
  - service-http.yaml.j2
  - service-bolt.yaml.j2
